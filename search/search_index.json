{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"cp/","text":"CleanPython A Python3 project model with several useful, standard and integrated tools to help you write clean, tested code by following the Zen of Python . If you start a Python project from scratch and need to write solid, tested, clean code, this repository might help. What is the clean code, and why is this important? Read here . Integrated tools Pytest useful to write data-driven tests, in a straightforward way and with less boilerplate pytest-benchmark makes easy to compare different functions performances Hypothesis \\\"property based testing\\\" really useful to find unexpected edge cases to test NB: no test examples, so far, in this repo Mypy static type checker for Python helps to find hidden bugs before they come up Coverage.py tells you which lines and branches are executed a 100% coverage should be the minimal quality requirement Pylint the most complete Python linter with several complexity metrics, it\\'s useful to keep your code clean, simple and readable can catch even duplicate code in different files! \ud83d\ude4c helps you to start refactoring before your code becomes too messy Flake8 helps to write standard, clean, and documented code wraps pep8, pyflakes, McCabe Complexity analysis supports plugins Isort Keep imports sorted alphabetically and grouped (standard, third party, local) Sphinx generates html documentation can auto-extract documentation from your codebase Poetry Poetry comes with all the tools you might need to manage your projects in a deterministic way Dependency resolver, isolation, cli Check the state of your dependencies Easily build and package your projects with a single command Make your work known by publishing it to PyPI just rules them all together in your workflow just check to make sure everything is OK just cov creates an HTML coverage report just doc generates your documentation Requirements Git Python3 Poetry just Usage Use this template First method (recommended): click on Use this template button to start a new repository with the CleanPython template. Then rename the project strings to your own name using the just rename command: just rename <project-name> <author> Alternatively, you clone the repository or download the archive and extract it in your project. Then initialize the git repo: just init <project-name> <author> It will create the first commit with the skeleton files. First step First installation from scratch (assume python virtualenv active): just startup # install the latest versions of requirements and check everything is ok If something fails, try: just install # use frozen requirements that are already checked Optionally, you can also install the git hooks (further automatic checks, pedantic): just install-hooks Badges If you want to add badges to your project associated with the actions setup in .github/workflows , you can use the following command: just badges <repo-name> <username> This adds three badges to the README.md file. Then commit and push the changes. To setup GitHub Pages, you have to create a branch named gh-pages and push it to the remote repository. Minimal workflow write tests first ( TDD ) write code until tests pass add your files to git index (e.g. git add -u ) just commit <your commit message> When you launch just commit , your whole code base is statically checked and tested before actually committing it. In case of any failure, the commit is aborted. To embed this check directly in git: just install-hooks (this could be fairly extreme, so these hooks are not installed by default). For example: are there broken tests? Fail. are you trying to get away without writing tests? Fail. does your function is too long? Fail. does your class contain too many methods or attributes? Fail. does your code is too complex? Fail. does your code follow a random style? Fail. You don\\'t want to waste time committing broken code, isn\\'t it? The time you don't spend writing tests will be lost later when bugs show up, with customer emails, and in the debugging phase. Prevention is better than cure. Recipes Make a complete code checkup (lint, test, and coverage): just check Run tests without the coverage.py overhead: just test Create and open your HTML test coverage: just cov Static code analysis (included in just check ): just lint Automatically fix the coding style: just fix Update dependencies and config files: just up Create your HTML documentation: just doc Run benchmarks (you have to write down them before :) ): just benchmarks Remove build artifacts (i.e. all untracked files, pay attention!): just clean Zen of Python The highlighted lines are the ones that, mostly, CleanPython ( explicitly or implicitly ) tries to help to reach. Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\\'t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you\\'re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it\\'s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let\\'s do more of those! Legend bold : explicitly, strongly targeted by CleanPython italic : implicitly or indirectly or weakly targeted by CleanPython","title":"CleanPython"},{"location":"cp/#cleanpython","text":"A Python3 project model with several useful, standard and integrated tools to help you write clean, tested code by following the Zen of Python . If you start a Python project from scratch and need to write solid, tested, clean code, this repository might help. What is the clean code, and why is this important? Read here .","title":"CleanPython"},{"location":"cp/#integrated-tools","text":"Pytest useful to write data-driven tests, in a straightforward way and with less boilerplate pytest-benchmark makes easy to compare different functions performances Hypothesis \\\"property based testing\\\" really useful to find unexpected edge cases to test NB: no test examples, so far, in this repo Mypy static type checker for Python helps to find hidden bugs before they come up Coverage.py tells you which lines and branches are executed a 100% coverage should be the minimal quality requirement Pylint the most complete Python linter with several complexity metrics, it\\'s useful to keep your code clean, simple and readable can catch even duplicate code in different files! \ud83d\ude4c helps you to start refactoring before your code becomes too messy Flake8 helps to write standard, clean, and documented code wraps pep8, pyflakes, McCabe Complexity analysis supports plugins Isort Keep imports sorted alphabetically and grouped (standard, third party, local) Sphinx generates html documentation can auto-extract documentation from your codebase Poetry Poetry comes with all the tools you might need to manage your projects in a deterministic way Dependency resolver, isolation, cli Check the state of your dependencies Easily build and package your projects with a single command Make your work known by publishing it to PyPI just rules them all together in your workflow just check to make sure everything is OK just cov creates an HTML coverage report just doc generates your documentation","title":"Integrated tools"},{"location":"cp/#requirements","text":"Git Python3 Poetry just","title":"Requirements"},{"location":"cp/#usage","text":"","title":"Usage"},{"location":"cp/#use-this-template","text":"First method (recommended): click on Use this template button to start a new repository with the CleanPython template. Then rename the project strings to your own name using the just rename command: just rename <project-name> <author> Alternatively, you clone the repository or download the archive and extract it in your project. Then initialize the git repo: just init <project-name> <author> It will create the first commit with the skeleton files.","title":"Use this template"},{"location":"cp/#first-step","text":"First installation from scratch (assume python virtualenv active): just startup # install the latest versions of requirements and check everything is ok If something fails, try: just install # use frozen requirements that are already checked Optionally, you can also install the git hooks (further automatic checks, pedantic): just install-hooks","title":"First step"},{"location":"cp/#badges","text":"If you want to add badges to your project associated with the actions setup in .github/workflows , you can use the following command: just badges <repo-name> <username> This adds three badges to the README.md file. Then commit and push the changes. To setup GitHub Pages, you have to create a branch named gh-pages and push it to the remote repository.","title":"Badges"},{"location":"cp/#minimal-workflow","text":"write tests first ( TDD ) write code until tests pass add your files to git index (e.g. git add -u ) just commit <your commit message> When you launch just commit , your whole code base is statically checked and tested before actually committing it. In case of any failure, the commit is aborted. To embed this check directly in git: just install-hooks (this could be fairly extreme, so these hooks are not installed by default). For example: are there broken tests? Fail. are you trying to get away without writing tests? Fail. does your function is too long? Fail. does your class contain too many methods or attributes? Fail. does your code is too complex? Fail. does your code follow a random style? Fail. You don\\'t want to waste time committing broken code, isn\\'t it? The time you don't spend writing tests will be lost later when bugs show up, with customer emails, and in the debugging phase. Prevention is better than cure.","title":"Minimal workflow"},{"location":"cp/#recipes","text":"Make a complete code checkup (lint, test, and coverage): just check Run tests without the coverage.py overhead: just test Create and open your HTML test coverage: just cov Static code analysis (included in just check ): just lint Automatically fix the coding style: just fix Update dependencies and config files: just up Create your HTML documentation: just doc Run benchmarks (you have to write down them before :) ): just benchmarks Remove build artifacts (i.e. all untracked files, pay attention!): just clean","title":"Recipes"},{"location":"cp/#zen-of-python","text":"The highlighted lines are the ones that, mostly, CleanPython ( explicitly or implicitly ) tries to help to reach. Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\\'t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you\\'re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it\\'s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let\\'s do more of those!","title":"Zen of Python"},{"location":"cp/#legend","text":"bold : explicitly, strongly targeted by CleanPython italic : implicitly or indirectly or weakly targeted by CleanPython","title":"Legend"}]}